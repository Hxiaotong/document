## 面试会涉及的知识点

### JavaScript知识点
1、六个原始类型：boolean、null、undefined、string、number、symbol

2、在JS中除了原始类型剩下的就都是对象（Object）类型了。原始类型存放的是值，对象类型存放的是地址（指针）。

3、typeof对于原始类型来说，除了null都可以显示正确的类型；对于对象类型来说除了函数都会显示object，所以typeof并不能准确的判断变量的类型。

4、如果想判断一个对象的正确类型，可以使用instanceof。

5、JS中类型转换只有三种情况：转换为布尔值、转换为数字、转换为字符串。

[类型转换](./img/类型转换.png)

6、四则运算符：

    1>、加法运算中，运算中一方为字符串，另一方也转换为字符串；如果一方不是字符串和数字，会将它转换成数字或字符串。

    2>、除了加法运算符，只要其中一方是数字，那么另一方就会被转换成为数字。

7、this的指向问题。

[this指向](./img/this.png)

[this与箭头函数](./img/this与箭头函数.png)

[this与bind](./img/this与bind.png)

[this绑定的优先级](./img/this绑定的优先级.png)

8、等号== 的判断过程。

[this绑定的优先级](./img/等号和全等.jpeg)

9、闭包函数：闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
``` js
for (var i = 1; i <= 5; i++) {
  ;(function(j) {
    setTimeout(function timer() {
      console.log(j)
    }, j * 1000)
  })(i)
}
```

10、浅拷贝

方式一：Object.assign（会拷贝所有的属性值到新的对象中）
``` js
let a = {
  age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```

方式二：展开运算符 ...
``` js
let a = {
  age: 1
}
let b = { ...a }
a.age = 2
console.log(b.age) // 1
```

11、深拷贝

方法一：JSON.parse(JSON.stringify(object))（在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化）

方法二：MessageChannel（这个方法不明白？？？？？）

方法三：lodash 的深拷贝函数
```js
function deepClone(obj) {
  function isObject(o) {
    return (typeof o === 'object' || typeof o === 'function') && o !== null
  }

  if (!isObject(obj)) {
    throw new Error('非对象')
  }

  let isArray = Array.isArray(obj)
  let newObj = isArray ? [...obj] : { ...obj }
  Reflect.ownKeys(newObj).forEach(key => {
    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]
  })

  return newObj
}

let obj = {
  a: [1, 2, 3],
  b: {
    c: 2,
    d: 3
  }
}
let newObj = deepClone(obj)
newObj.b.c = 1
console.log(obj.b.c) // 2
```

12、原型：对于 obj 来说，可以通过 __proto__ 找到一个原型对象，在该对象中定义了很多函数让我们来使用。
打开 constructor 属性我们又可以发现其中还有一个 prototype 属性，并且这个属性对应的值和先前我们在 __proto__ 中看到的一模一样。所以我们又可以得出一个结论：原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，但是并不是所有函数都具有这个属性，Function.prototype.bind() 就没有这个属性。

每个 JS 对象都有 __proto__ 属性，这个属性指向了原型。
原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 obj 来说，可以通过 __proto__ 找到一个原型对象，在该对象中定义了很多函数让我们来使用。
constructor 属性，也就是构造函数。

[this绑定的优先级](./img/原型.jpeg)

1. Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它
2. Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它
3. 函数的 prototype 是一个对象
4. 对象的 __proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链
